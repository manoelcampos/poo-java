:imagesdir: images

== Porque Programa√ß√£o Orientada a Objetos?

A forma de escrever c√≥digo vem evoluindo h√° d√©cadas para resolver muitos dos problemas apresentados no cap√≠tulo anterior.
V√°rios paradigmas de programa√ß√£o t√™m sido desenvolvidos para melhorar a forma como escrevemos c√≥digo, visando principalmente tornar o c√≥digo mais claro, organizado, f√°cil de manter e menos suscet√≠vel a erros (bugs). 

At√© a d√©cada de 60 era muito comum o desenvolvimento de programas utilizando o paradigma de <<Unstructured,Programa√ß√£o n√£o Estruturada>>, que resultava em c√≥digo dif√≠cil de entender e manter. Por estes motivos, um c√≥digo escrito usando tal paradigma √© chamado pejorativamente de c√≥digo espaguete, por ser confuso e n√£o ter uma sequ√™ncia clara. Muitos dos c√≥digos escrito seguindo este paradigma utilizavam linguagens como https://pt.wikipedia.org/wiki/Assembly[Assembly] que, apesar de serem leg√≠veis para humanos, n√£o s√£o t√£o leg√≠veis quanto as linguagens atuais.

.Como √© organizado um c√≥digo espaguete üò≥. (Fonte: link:https://pt.123rf.com/photo_65290422_caos-de-cabos-e-fios-no-p√≥lo-el√©trico-em-chiang-mai%20-tail√¢ndia.html[123rf.com]])
image::chaos-of-cables.jpg[width=480]

image::assembly.gif[title=Exemplo de c√≥digo em linguagem Assembly]

Outras formas de desenvolver programas foram ent√£o surgindo. Uma evolu√ß√£o natural da Programa√ß√£o n√£o Estruturada foi a https://pt.wikipedia.org/wiki/Programa√ß√£o_estruturada[Programa√ß√£o Estruturada]. Este foi provavelmente o primeiro paradigma de programa√ß√£o que voc√™ aprendeu em l√≥gica de programa√ß√£o. Um c√≥digo estruturado permite visualizar mais facilmente o fluxo l√≥gico de execu√ß√£o de um programa. Com isto, √© poss√≠vel facilmente criar algoritmos visualmente por meio de https://manoelcampos.gitbooks.io/logica-programacao/content/chapter1.html#representacao[fluxogramas ou blocos].

image::fluxograma.png[title="Como um algoritmo estruturado pode ser representado em um fluxograma.", width=480]

TIP: O paradigma estruturado √© tamb√©m definido como "a atitude de escrever c√≥digo com a inten√ß√£o de se comunicar com humanos e n√£o com m√°quinas" <<Unstructured>>. Ou seja, um dos grandes objetivos de um c√≥digo √© que ele seja leg√≠vel para outros programadores.

Apesar do paradigma estruturado ter tornado a programa√ß√£o de computadores bem mais simples e o c√≥digo mais claro, ela ainda peca em muitos pontos como:

- image:shapes.jpg[role="right" width=120, link="https://www.pinterest.pt/pin/693413673846671893/"] divis√£o do problema: um problema muitas vezes pode ser dividido em v√°rias partes para tornar mais f√°cil sua resolu√ß√£o. A divis√£o de tais partes de modo que elas trabalhem em conjunto posteriormente deve ser feita de forma adequada.
- image:problem-solution.jpg[role="right" width=240, link="https://pt.123rf.com/photo_41818211_business-strategy-businessman-planning-and-finding-a-solution-through-a-drawing-of-a-labyrinth-maze.html"] representa√ß√£o da solu√ß√£o de um problema: uma dos grandes desafios em programa√ß√£o √© entender o que um determinado c√≥digo faz, principalmente se ele foi escrito por outra pessoa. A representa√ß√£o de um c√≥digo de uma forma que seja pr√≥xima do problema que ele resolve torna mais f√°cil identificar se ele faz o que √© esperado; image:reinventing-wheel.jpg[role="right" width=180, link="https://www.aic.cuhk.edu.hk/web8/Reinventing%20the%20wheel.htm"] 
- reutiliza√ß√£o de c√≥digo, para:
    * evitar ter que ficar reinventando a roda;
    * evitar re-escrever c√≥digo que voc√™ j√° fez (princ√≠pio <<PP,DRY>>: Don't Repeat Yourself = N√£o Repita Voc√™ mesmo) e avitando a famigerada https://en.wikipedia.org/wiki/Copy_and_paste_programming["Programa√ß√£o Copia e Cola"] üò© image:copy_paste_keyboard.jpg[role=right, width=180, link=https://www.timeshighereducation.com].
- permitir proteger tanto dados quanto determinadas partes do c√≥digo de serem usados de maneira indevida, o que poderia gerar bugs;
- etc.

Um dos problemas da altera√ß√£o indevida de dados surge quando s√£o utilizadas vari√°veis globais, como no caso do pseudo c√≥digo apresentado abaixo. O objetivo do algoritmo √© solicitar n√∫meros ao usu√°rio at√© que ele digite zero para terminar. A cada n√∫mero digitado o programa deve exibir a soma de todos os n√∫meros digitados at√© ent√£o. Tente identificar o que est√° errado com este c√≥digo.

.Algoritmo incorreto para somar n√∫meros.
```
total = 0

funcao soma_numeros(){
    fa√ßa {
        imprime("Digite um n√∫mero: ")
        leia(numero)
        total = total + numero
        mostra_subtotal()
    } enquanto (numero != 0)
}

funcao mostra_subtotal() {
    imprime("O total calculado at√© agora √© de ", total)
    total = 0
}
```

A https://pt.wikipedia.org/wiki/Programa√ß√£o_procedural[Programa√ß√£o Procedural] permite resolver alguns destes problemas (como o apresentado no algoritmo acima), mas nem sempre √© simples, efetivo e adapt√°vel a diferentes necessidades.

.Programa√ß√£o Copia e Cola e POG
****
A Programa√ß√£o Copia e Cola apresentada anteriormente √© um dos artif√≠cios que programadores usam para resolver muitos problemas. Mas a mundialmente conhecida Programa√ß√£o Orientada a Gambiarras (POG) trouxe avan√ßaos significativos na √°rea.

video::45I9jX5uO9A[youtube, width="100%", height="300vh"]
****

image:oop-to-the-rescue.png[role=right, link=https://toggl.com/programming-princess, width=200] Assim, surgiu a Programa√ß√£o Orientada a Objetos (POO). Mas antes de explicar como a POO funciona e como ela resolve muitos dos problemas apresentados, vamos olhar o mundo ao nosso redor. N√≥s estamos cercados de objetos para todos os lados, como pr√©dios, carros, celulares, TVs e livros. Todos estes objetos t√™m suas caracter√≠sticas e funcionalidades, como exemplificado na tabela a seguir:


.Caracter√≠sticas e funcionalidades de objetos comuns
|===
|Objeto | Caracter√≠sticas | Funcionalidades

| Carro | *Cor*: Azul, *Ano Fabrica√ß√£o*: 2012, *Bancos*: couro | Acelerar, Frenar, Limpar parabrisas, Acender far√≥is
| TV | *Tamanho*: 42", *Tela*: LCD, *Classifica√ß√£o Energ√©tica*: A | Ligar/Desligar, Trocar canais, Acionar Timer, Exibir guia de programa√ß√£o
|===

TIP: As caracter√≠sticas de um objeto s√£o qualidades (adjetivos) e as funcionalidades s√£o a√ß√µes (verbos), assim √© f√°cil distingu√≠-las.

Como atualmente √© poss√≠vel criar https://manoelcampos.gitbooks.io/logica-programacao/content/[programas para controlar objetos como carros, TVs, rel√≥gios, balan√ßas, porteiros eletr√¥nicos, l√¢mpadas, portas e muito mais], a POO aproxima a representa√ß√£o de tais objetos em um programa com os mesmo objetos no mundo real.


image:shopping-cart.jpg[role=right, width=180, link=https://financesonline.com/top-10-alternatives-magento-leading-shopping-cart-software-solutions/] Mas n√£o se assuste, POO n√£o pode ser usada apenas para tarefas complexas como programa√ß√£o de carros inteligentes. Vamos usar um exemplo mais comum: as lojas virtuais na Internet. Tais lojas possuem sites, que nada mais s√£o do que aplica√ß√µes (programas) para a Internet. As p√°ginas que permitem busca e exibi√ß√£o de produtos nestes sites s√£o programas normalmente desenvolvidos utilizando-se o pagadigma de orienta√ß√£o a objetos. Para produtos serem exibidos no site, eles precisam ser representados no c√≥digo escrito pelo programador. Tais produtos s√£o objetos que possuem suas caracter√≠sticas e funcionalidades reais que devem ser representadas ao desenvolver uma loja virtual.

Na POO, objetos podem ser pessoas, animais e qualquer coisa que precise ser representada para resolver um problema. Por exemplo, na loja virtual, para realiza√ß√£o de uma compra, √© preciso identificar o cliente. Este √© uma pessoa que precisa ter algumas caracter√≠sticas registradas como nome, sexo, data de nascimento, email e endere√ßo. As funcionalidades desta pessoa podem ser alterar senha e adicionar endere√ßo. 

[bibliography]
== Refer√™ncias

- [[[Spaguetti]]] Conway, Richard (1978). A primer on disciplined programming using PL/I, PL/CS, and PL/CT. Winthrop Publishers. ISBN 0-87626-712-6
- [[[Unstructured]]] Cobb, Gary W. (1978). "A measurement of structure for unstructured programming languages". ACM SIGSOFT Software Engineering Notes. 3 (5): 140‚Äì147. ISSN 0163-5948. doi:10.1145/953579.811114.
- [PP] Hunt, Andrew, and David Thomas. O Programador Pragm√°tico: de aprendiz a mestre. Bookman Editora, 2009.
