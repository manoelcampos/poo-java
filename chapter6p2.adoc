:imagesdir: images

== Relacionamentos Bi-Direcionais e 1..n

Como vimos, √© muito simples criar relacionamentos com cardinalidade 1..1, como o relacionamento `Empresa` -> `Cidade`. J√° sabemos que a dire√ß√£o da seta indica que objeto ter√° acesso ao outro objeto na associa√ß√£o. No relacionamento apresentado, a partir de uma `Empresa` poderemos saber qual a `Cidade` em que ela est√° situada. No entanto, a partir da `Cidade`, n√£o temos como saber quais empresas est√£o situadas l√°. Se realmente necessitamos deta infroma√ß√£o, precisamos criar um relacionamento no sentido contr√°rio, de `Cidade` para `Empresa`.

Ao fazermos isso, estaremos criando um relacionamento bi-direcional entre as duas classes. Na pr√°tica, estamos criando dois relacionamentos uni-direcionais em sentidos contr√°rios. Dependendo da ferramenta de desenvolvimento ou modelagem utilizada, isto ser√° representado como um √∫nico relacionamento com setas em ambos os lados (bi-direcional) ou duas setas individuais (dois relacionamentos uni-direcionais). O BlueJ adota a segunda op√ß√£o, que inclusive √© mais did√°tica, pois mostra que s√£o de fato relacionamentos individuais, que precisam ser programados separadamente. 

Ao criar um relacionamento em um sentido, o relacionamento no sentido contr√°rio n√£o √© criado automaticamente, pois podemos simplesmente n√£o precisar dele. Assim, cri√°-lo √© uma escolha, de acordo com as necessidades do sistema. Vamos ent√£o criar o relacionamento `Cidade` -> `Empresa` como 1..n. Para isto, segue-se a l√≥gica utilizada para os outros relacionamentos: dentro da classe de origem (`Cidade` neste caso), devemos incluir um atributo da classe de destino (`Empresa`). 

No entanto, com relacionamentos 1..n √© preciso algumas modifica√ß√µes. Como a cidade pode ter v√°rias empresas, precisar√≠amos de uma estrutura como um vetor, por exemplo, para permitir que uma cidade guardasse a rela√ß√£o de empresas l√° situadas. A declara√ß√£o de vetores em Java √© muito simples, como `Empresa []empresas;`. Observe que basta utilizar colcheques vazios para declarar um vetor. Por√©m, em Java, depois que o tamanho de um vetor √© definido, n√£o se pode mais aumentar nem diminuir a quantidade de elementos de tal vetor. Se usarmos um vetor para representar as empresas de uma cidade, antes de come√ßar a utilizar tal vetor precisaremos instanciar o mesmo, indicando a quantidade de elementos que o vetor comportar√°. 

Poder√≠amos fazer isso no construtor da classe `Cidade` como `this.empresas = new Empresa[10];`. Com esta linha estamos instanciando (`new`) um vetor que pode armazenar at√© 10 empresas, onde:

- os colchetes indicam que a vari√°vel √© um vetor, 
- o valor entre eles representa a capacidade do vetor;
- e `Empresa` indica o tipo de elementos que podem ser armazenados nas posi√ß√µes do vetor.

O grande problema do uso de vetores para representar relacionamentos 1..n √© que n√£o sabemos quantas empresas cada cidade ter√°. O tamanho escolhido para o vetor pode ser exagerado ou insuficiente. Cada cidade ter√° uma quantidade diferente de empresas e estas podem aumentar ou diminuir ao longo do tempo. Se o tamanho do vetor for exagerado, vamos desperdi√ßar mem√≥ria, criando um vetor com muitas posi√ß√µes que dificilmente ser√£o usadas. Se for insuficiente, chegar√° um momento em que novas empresas n√£o poder√£o ser adicionadas √† uma cidade. 

IMPORTANT: A √∫nica forma de aumentar a quantidade de elementos em um vetor √©, criar um novo vetor de maior capacidade e copiar os elementos do vetor antigo para o novo. 

https://www.ibm.com/developerworks/java/library/j-5things2/index.html[Por esses e outros motivos] que est√£o fora do escopo deste curso, o uso direto de vetores em Java √© desaconselh√°vel em v√°rias situa√ß√µes. Vetores s√£o excelentes estruturas que permitem armazenar um conjunto de dados sequencialmente na mem√≥ria. Se voc√™ precisa imprimir todos os elementos de um vetor, percorr√™-lo utilizando um la√ßo de repeti√ß√£o √© incrivelmente r√°pido. No entanto, devido √† problemas como os apresentados no par√°grafo anterior, vetores devem ser usados em Java quando voc√™ for obrigado a utiliz√°-los (pois um determinado m√©todo exige um vetor) ou: 

- o problema a ser resolvido √© muito simples e dispensa qualquer estrutura mais complexa;
- o vetor ser√° utilizado apenas internamente em um determinado m√©todo, sem ser retornando por tal m√©todo;
- voc√™ sabe quantos elementos precisa armazenar e o total de elementos n√£o muda;
- ou h√° quest√µes de desempenho que voc√™ j√° avaliou e descobriu que a melhor alternativa √© o uso de vetores. Nem sempre o uso de vetores ser√° a alternativa mais eficiente e h√° cursos inteiros sobre estruturas de dados e complexidade de algoritmos que discutem tais aspectos.

[NOTE]
====
Existe uma express√£o em computa√ß√£o que diz _"Measure, don't guess"_, ou seja, "me√ßa, n√£o advinhe", significando basicamente que supor que uma solu√ß√£o vai melhorar o desempenho de um sistema sem ter feito as devidas medi√ß√µes √© uma aposta, um "chute".
Assim, simplesmente supor que o uso de vetores vai melhorar o desempenho, sem antes ter utilizado ferramentas de medi√ß√£o, √© apenas um palpite. Para mais detalhes, veja https://dzone.com/articles/microbenchmarking-jmh-measure[este artigo (apenas em ingl√™s)].
====

No lugar de vetores, o mais recomend√°vel √© o uso da Java Collections Framework (JCF), uma biblioteca de classes para trabalhar com cole√ß√µes de elementos. Esta √© uma biblioteca moderna, eficiente e provavelmente a mais conhecida e utilizada de toda a plataforma Java. 

[quote, Oleg Shelajev, 'https://zeroturnaround.com/rebellabs/java-collections-cheat-sheet/[ZeroTurnaround]']
____
Todo programa Java tende a ter uma coisa em comum: eles usar√£o cole√ß√µes.
____

Como a JCF disponibiliza uma s√©rie de classes, isto significa que a grande maioria dos problemas relacionados ao uso de vetores √© resolvida por meio de m√©todos disponibilizados por tais classes. Como indicado anteriormente, a √∫nica forma de aumentar o tamanho de um vetor √© criar outro e copiar os dados do anterior para o novo vetor. Utilizando vetores diretamente, seria preciso implementar m√©todos para realizar tais opera√ß√µes. Com a JCF (que chamamos tamb√©m simplesmente de Collections), todos esses m√©todos j√° est√£o prontos e n√£o precisamos perder tempo reinventando a roda.

=== Como usar Collections para criar relacionamentos 1..n

No caso do relacionamento 1..n entre `Cidade` -> `Empresa`, como j√° sabemos, devemos incluir um atributo `Empresa` dentro da classe `Cidade`, que permite armazenar o conjunto de empresas de uma cidade. Vamos fazer isso usando uma das classes da JCF. Mas primeiro, vamos recapitular a sintaxe para a declara√ß√£o de um vetor, que segue a estrutura `ClasseOuTipoPrimitivoDosItemsDoVetor []nomeDaVariavel;` como por exemplo `Empresa empresas[]` que cria um vetor de empresas. 

Se voc√™ fez l√≥gica de programa√ß√£o ou introdu√ß√£o √† programa√ß√£o, sabe que vetores s√£o tipos compostos homog√™neos, ou seja, podemos armazenar v√°rios dados, por√©m todos de um mesmo tipo. As classes da JCF tamb√©m podem ser classificadas da mesma forma. A declara√ß√£o de um vetor √© divida em 3 partes:

. `[]` (colchetes) para indicar que queremos criar um vetor (sem isto estaremos apenas criando uma vari√°vel comum, que armazena um √∫nico valor);
. `ClasseOuTipoPrimitivoDosItemsDoVetor` para indicar o tipo primitivo ou classe dos elementos que podem ser armazenados;
. `nomeDaVariavel` o nome da vari√°vel que representar√° o vetor. 

Ao declarar uma vari√°vel utilizando alguma classe da JCF, precisamos seguir os mesmos passos, mas com uma sintaxe diferente: `ClasseDeColecao<ClasseDosItemsDaColecao> nomeDaVariavel`. Uma vez que tais classes n√£o s√£o vetores, √© necess√°rio uma sintaxe diferente para que o compilador entenda que n√£o queremos criar um vetor. No entanto, tamb√©m usamos 3 partes para declarar tal vari√°vel:

. `ClasseDeColecao` para indicar que queremos criar uma cole√ß√£o, utilizando alguma das classes do pacote `java.util`. A classe mais b√°sica para isso √© a `ArrayList`, que representa uma lista de objetos.
. `<ClasseDosItemsDaColecao>` para indicar qual a classe dos elementos que podem ser armazenados (perceba o uso de `<>` para isto, diferente dos `[]` usados para vetores).
. `nomeDaVariavel` o nome da vari√°vel que representar√° a cole√ß√£o. 

Um exemplo que cria uma cole√ß√£o de empresas pode ser `ArrayList<Empresa> empresas`. Neste caso estamos utilizando um tipo espec√≠fico de cole√ß√£o √© que uma lista (`List`), mais especificamente, um determinado tipo de lista que √© o `ArrayList`. Podemos ent√£o dizer que a vari√°vel `empresas` √© uma lista de empresas. 

Diversas linguagens de programa√ß√£o possuem esse conceito de cole√ß√µes. Apesar de cada linguagem implementar cole√ß√µes de uma forma diferente, podendo mudar termos e incluir outros, os fundamentos apresentados aqui tornar√£o mais f√°cil a utiliza√ß√£o de cole√ß√µes em outras linguagens. Parece ser muito complicado, mas logo voc√™ se acostuma, assim como vetores j√° √© um conceito familiar. 

Ent√£o finalmente, para declararmos nossa lista de empresas, vamos incluir o atributo `empresas` dentro da classe `Cidade`, como abaixo:

[source,java]
----
public class Cidade
{
    private String nome;
    private Estado estado;

    /**
     * Define o relacionamento Cidade -> Empresa como 1..n.
     */
    private ArrayList<Empresa> empresas;

    //Getters e setters omitidos por simplifica√ß√£o
}
----

Ao tentar compilar o c√≥digo da classe, ser√° gerado o erro _"cannot find symbol - class ArrayList"_, indicando que a classe `ArrayList` n√£o foi encontrada. Esta √© a primeira vez que vemos tal erro e ele ocorre pois a classe indicada est√° em um pacote espec√≠fico. Um diret√≥rio no disco √© uma forma de representa√ß√£o de pacotes em Java, contendo um conjunto de classes. `ArrayList` √© uma classe da linguagem, dispon√≠vel no pacote `java.util`. Desta forma, precisamos importar tal classe para podermos utiliz√°-la em nosso c√≥digo, incluindo um comando `import nome.do.pacote.NomeDaClassePraImportar;` na primeira linha do arquivo java onde a classe importada ser√° usada. Se voc√™ j√° programou em outras linguagens, este conceito de `import` √© o mesmo em linguagens como Python e vers√µes mais recentes do JavaScript. Em outras linguagens temos:

- `include` em C e PHP;
- `require` em PHP.

Desta forma, a linha `import java.util.ArrayList;` deve ser inclu√≠da como primeira linha do arquivo da classe `Cidade`.
Voc√™ pode estar se perguntando porque outras classes como `String` n√£o precisaram de um import. Isto se deve ao fato de que `String` √© uma classe do pacote chamado `java.lang` e o compilador Java importa automaticamente qualquer classe desse pacote, nos dispensando deste trabalho. Veremos mais sobre pacotes mais adiante. O c√≥digo da classe ent√£o fica como abaixo.

[source,java]
----
import java.util.ArrayList;

public class Cidade
{
    private String nome;
    private Estado estado;
    private ArrayList<Empresa> empresas;

    //Getters e setters omitidos por simplifica√ß√£o
}
----

Voltando ao nosso c√≥digo, vemos que `empresas` nada mais √© que um atributo da classe `Cidade`. Assim, o pr√≥ximo passo seria adicionar um _getter_ e um _setter_ para ele. No entanto, h√° um por√©m quando usamos uma cole√ß√£o. Se inclu√≠rmos um _setter_, ao chamar tal m√©todo, precisaremos informar uma lista completa de empresas situadas naquela cidade. Mas n√£o √© assim a forma tradicional de se preencher uma lista. Se resolvermos fazer uma lista de compras, vamos inclu√≠ndo os elementos em tal lista um a um. Assim tamb√©m √© a forma mais pr√°tica de ser feito em programa√ß√£o. No entanto, √© muito comum programadores iniciantes simplesmente criarem _getter_ e _setter_ para listas de forma autom√°tica, como fazem para qualquer atributo. O _getter_ ser√° √∫til para sabermos quais empresas h√° na cidade, mas o setter acabar√° n√£o sendo muito pr√°tico, pois como falado, a lista √© mais facilmente preenchida adicionando-se um elemento por vez.

Desta forma, criaremos o _getter_ e, no lugar do _setter_, vamos criar um m√©todo chamado `addEmpresa` que adicionar√° uma empresa √† lista de empresas da cidade. Assim, o c√≥digo da classe `Cidade` ficar√° como abaixo:

[source,java]
----
import java.util.ArrayList;

public class Cidade
{
    private String nome;
    private Estado estado;
    private ArrayList<Empresa> empresas;
    //Getters e setters para nome e estado omitidos por simplifica√ß√£o

    public ArrayList<Empresa> getEmpresas(){
        return empresas;
    }

    public void addEmpresa(Empresa empresa){
        empresas.add(empresa);
    }
}
----

O v√≠deo a seguir demonstra o processo de instancia√ß√£o de uma Empresa e uma Cidade. No entanto, como podem ver, ao tentar adicionar uma Empresa criada √† lista de empresas da Cidade, ocorre o erro NullPointerException.

video::jDlUtqXHAl4[youtube, 640, 480]

O erro ocorre pois estamos tentando utilizar a lista de empresas antes de termos instanciado a mesma.
Observe que em nenhum momento, dentro do c√≥digo da classe `Cidade`, utilizamos o operador `new` para criar uma 
lista vazia e assim podermos inserir empresas nela. Como √© √≥bvio, se vamos fazer uma lista de compras, primeiramente precisamos conseguir, por exemplo, uma folha de papel (preferencialmente em branco) para podermos come√ßar a adicionar os elementos na nossa lista. Este √© o passo que nos falta no c√≥digo acima. Como visto no link::chapter5.html[Cap√≠tulo 5], podemos utilizar um construtor para definir valores iniciais para atributos da nossa classe. Como `empresas` √© um atributo, podemos ent√£o instanci√°-lo em um construtor padr√£o na classe Cidade, e assim incluir nosso construtor depois do √∫ltimo atributo da classe (preferencialmente), como abaixo:

[source,java]
----
    public Cidade(){
        this.empresas = new ArrayList<Empresa>();        
    }
----

Se seguirmos os mesmos passos do v√≠deo acima, agora conseguiremos adicionar empresas √† lista de empresas da cidade, uma empresa por vez. Um detalhe que precisamos ter em mente √© a forma como uma `ArrayList` deve ser intanciada. Como j√° sabemos, a forma mais b√°sica de instanciar qualquer objeto √© `new NomeDaClasse()`. Apesar de a linha no construtor acima parece diferente, ela segue a mesma l√≥gica: utilizamos `new` seguido da classe do objeto que queremos instanciar. Neste caso, o tipo da vari√°vel `empresas` que armazenar√° uma refer√™ncia para tal objeto n√£o √© apenas `ArrayList`, mas sim `ArrayList<Empresa>`. O tipo de uma vari√°vel √© o que vem imediatamente antes dela. 

Se olharmos a declara√ß√£o de `empresas` no c√≥digo anterior ao mostrado acima, veremos que o que vem antes do nome do atributo √© `ArrayList<Empresa>`. Observe que n√£o h√° espa√ßo entre `ArrayList` e `<Empresa>` (apesar de ser perfeitamente v√°lido incluir espa√ßo), indicando que eles s√£o uma coisa s√≥, representando um √∫nico tipo: uma lista de empresas.

Assim, para instanciar tal lista, precisamos usar `new ArrayList<Empresa>();` e n√£o `new ArrayList();`.
Esta √∫ltima forma mostrada funciona, mas n√£o √© a maneira correta de instanciar objetos como cole√ß√µes desde o Java 5, que foi lan√ßado em 2004. Se voc√™ usar esta segunda forma, √© como se tivesse parado no tempo h√° mais de uma d√©cada, o que seria uma vergonha üòí. 

Avan√ßando alguns anos para o Java 7 de 2011, deixamos de precisar indicar o tipo de elementos da cole√ß√£o no momento de instanci√°-la. S√≥ precisamos fazer isso ao declarar as vari√°veis. Assim, podemos apenas deixar o `<>` vazio dentro do construtor. Se utilizarmos da forma acima, ferramentas de desenvolvimento v√£o sugerir que aquela n√£o √© a forma mais adequada e atual. Nossa classe ent√£o fica como abaixo:

[source,java]
----
import java.util.ArrayList;

public class Cidade
{
    private String nome;
    private Estado estado;
    private ArrayList<Empresa> empresas;
    //Getters e setters para nome e estado omitidos por simplifica√ß√£o

    public Cidade(){
        /*
        Observe que removemos o tipo dos elementos 
        da lista de dentro do <>.
        Isto s√≥ pode ser feito no momento de instanciar a lista.
        */
        this.empresas = new ArrayList<>();        
    }

    public ArrayList<Empresa> getEmpresas(){
        return empresas;
    }

    public void addEmpresa(Empresa empresa){
        empresas.add(empresa);
    }
}
----
