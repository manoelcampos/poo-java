:imagesdir: images

== Relacionamentos Bi-Direcionais e 1..n

Como vimos, √© muito simples criar relacionamentos com cardinalidade 1..1, como o relacionamento `Empresa` -> `Cidade`. J√° sabemos que a dire√ß√£o da seta indica que objeto ter√° acesso ao outro objeto na associa√ß√£o. No relacionamento apresentado, a partir de uma `Empresa` poderemos saber qual a `Cidade` em que ela est√° situada. No entanto, a partir da `Cidade`, n√£o temos como saber quais empresas est√£o situadas l√°. Se realmente necessitamos deta infroma√ß√£o, precisamos criar um relacionamento no sentido contr√°rio, de `Cidade` para `Empresa`.

Ao fazermos isso, estaremos criando um relacionamento bi-direcional entre as duas classes. Na pr√°tica, estamos criando dois relacionamentos uni-direcionais em sentidos contr√°rios. Dependendo da ferramenta de desenvolvimento ou modelagem utilizada, isto ser√° representado como um √∫nico relacionamento com setas em ambos os lados (bi-direcional) ou duas setas individuais (dois relacionamentos uni-direcionais). O BlueJ adota a segunda op√ß√£o, que inclusive √© mais did√°tica, pois mostra que s√£o de fato relacionamentos individuais, que precisam ser programados separadamente. 

Ao criar um relacionamento em um sentido, o relacionamento no sentido contr√°rio n√£o √© criado automaticamente, pois podemos simplesmente n√£o precisar dele. Assim, cri√°-lo √© uma escolha, de acordo com as necessidades do sistema. Vamos ent√£o criar o relacionamento `Cidade` -> `Empresa` como 1..n. Para isto, segue-se a l√≥gica utilizada para os outros relacionamentos: dentro da classe de origem (`Cidade` neste caso), devemos incluir um atributo da classe de destino (`Empresa`). 

No entanto, com relacionamentos 1..n √© preciso algumas modifica√ß√µes. Como a cidade pode ter v√°rias empresas, precisar√≠amos de uma estrutura como um vetor, por exemplo, para permitir que uma cidade guardasse a rela√ß√£o de empresas l√° situadas. A declara√ß√£o de vetores em Java √© muito simples, como `Empresa []empresas;`. Observe que basta utilizar colcheques vazios para declarar um vetor. Por√©m, em Java, depois que o tamanho de um vetor √© definido, n√£o se pode mais aumentar nem diminuir a quantidade de elementos de tal vetor. Se usarmos um vetor para representar as empresas de uma cidade, antes de come√ßar a utilizar tal vetor precisaremos instanciar o mesmo, indicando a quantidade de elementos que o vetor comportar√°. 

Poder√≠amos fazer isso no construtor da classe `Cidade` como `this.empresas = new Empresa[10];`. Com esta linha estamos instanciando (`new`) um vetor que pode armazenar at√© 10 empresas, onde:

- os colchetes indicam que a vari√°vel √© um vetor, 
- o valor entre eles representa a capacidade do vetor;
- e `Empresa` indica o tipo de elementos que podem ser armazenados nas posi√ß√µes do vetor.

O grande problema do uso de vetores para representar relacionamentos 1..n √© que n√£o sabemos quantas empresas cada cidade ter√°. O tamanho escolhido para o vetor pode ser exagerado ou insuficiente. Cada cidade ter√° uma quantidade diferente de empresas e estas podem aumentar ou diminuir ao longo do tempo. Se o tamanho do vetor for exagerado, vamos desperdi√ßar mem√≥ria, criando um vetor com muitas posi√ß√µes que dificilmente ser√£o usadas. Se for insuficiente, chegar√° um momento em que novas empresas n√£o poder√£o ser adicionadas √† uma cidade. 

IMPORTANT: A √∫nica forma de aumentar a quantidade de elementos em um vetor √©, criar um novo vetor de maior capacidade e copiar os elementos do vetor antigo para o novo. 

https://www.ibm.com/developerworks/java/library/j-5things2/index.html[Por esses e outros motivos] que est√£o fora do escopo deste curso, o uso direto de vetores em Java √© desaconselh√°vel em v√°rias situa√ß√µes. Vetores s√£o excelentes estruturas que permitem armazenar um conjunto de dados sequencialmente na mem√≥ria. Se voc√™ precisa imprimir todos os elementos de um vetor, percorr√™-lo utilizando um la√ßo de repeti√ß√£o √© incrivelmente r√°pido. No entanto, devido √† problemas como os apresentados no par√°grafo anterior, vetores devem ser usados em Java quando voc√™ for obrigado a utiliz√°-los (pois um determinado m√©todo exige um vetor) ou: 

- o problema a ser resolvido √© muito simples e dispensa qualquer estrutura mais complexa;
- o vetor ser√° utilizado apenas internamente em um determinado m√©todo, sem ser retornando por tal m√©todo;
- voc√™ sabe quantos elementos precisa armazenar e o total de elementos n√£o muda;
- ou h√° quest√µes de desempenho que voc√™ j√° avaliou e descobriu que a melhor alternativa √© o uso de vetores. Nem sempre o uso de vetores ser√° a alternativa mais eficiente e h√° cursos inteiros sobre estruturas de dados e complexidade de algoritmos que discutem tais aspectos.

[NOTE]
====
Existe uma express√£o em computa√ß√£o que diz _"Measure, don't guess"_, ou seja, "me√ßa, n√£o advinhe", significando basicamente que supor que uma solu√ß√£o vai melhorar o desempenho de um sistema sem ter feito as devidas medi√ß√µes √© uma aposta, um "chute".
Assim, simplesmente supor que o uso de vetores vai melhorar o desempenho, sem antes ter utilizado ferramentas de medi√ß√£o, √© apenas um palpite. Para mais detalhes, veja https://dzone.com/articles/microbenchmarking-jmh-measure[este artigo (apenas em ingl√™s)].
====

No lugar de vetores, o mais recomend√°vel √© o uso da Java Collections Framework (JCF), uma biblioteca de classes para trabalhar com cole√ß√µes de elementos. Esta √© uma biblioteca moderna, eficiente e provavelmente a mais conhecida e utilizada de toda a plataforma Java. 

[quote, Oleg Shelajev, 'https://zeroturnaround.com/rebellabs/java-collections-cheat-sheet/[ZeroTurnaround]']
____
Todo programa Java tende a ter uma coisa em comum: eles usar√£o cole√ß√µes.
____

Como a JCF disponibiliza uma s√©rie de classes, isto significa que a grande maioria dos problemas relacionados ao uso de vetores √© resolvida por meio de m√©todos disponibilizados por tais classes. Como indicado anteriormente, a √∫nica forma de aumentar o tamanho de um vetor √© criar outro e copiar os dados do anterior para o novo vetor. Utilizando vetores diretamente, seria preciso implementar m√©todos para realizar tais opera√ß√µes. Com a JCF (que chamamos tamb√©m simplesmente de Collections), todos esses m√©todos j√° est√£o prontos e n√£o precisamos perder tempo reinventando a roda.

=== Como usar Collections para criar relacionamentos 1..n

No caso do relacionamento 1..n entre `Cidade` -> `Empresa`, como j√° sabemos, devemos incluir um atributo `Empresa` dentro da classe `Cidade`, que permite armazenar o conjunto de empresas de uma cidade. Vamos fazer isso usando uma das classes da JCF. Mas primeiro, vamos recapitular a sintaxe para a declara√ß√£o de um vetor, que segue a estrutura `ClasseOuTipoPrimitivoDosItemsDoVetor []nomeDaVariavel;` como por exemplo `Empresa empresas[]` que cria um vetor de empresas. 

Se voc√™ fez l√≥gica de programa√ß√£o ou introdu√ß√£o √† programa√ß√£o, sabe que vetores s√£o tipos compostos homog√™neos, ou seja, podemos armazenar v√°rios dados, por√©m todos de um mesmo tipo. As classes da JCF tamb√©m podem ser classificadas da mesma forma. A declara√ß√£o de um vetor √© divida em 3 partes:

. `[]` (colchetes) para indicar que queremos criar um vetor (sem isto estaremos apenas criando uma vari√°vel comum, que armazena um √∫nico valor);
. `ClasseOuTipoPrimitivoDosItemsDoVetor` para indicar o tipo primitivo ou classe dos elementos que podem ser armazenados;
. `nomeDaVariavel` o nome da vari√°vel que representar√° o vetor. 

Ao declarar uma vari√°vel utilizando alguma classe da JCF, precisamos seguir os mesmos passos, mas com uma sintaxe diferente: `ClasseDeColecao<ClasseDosItemsDaColecao> nomeDaVariavel`. Uma vez que tais classes n√£o s√£o vetores, √© necess√°rio uma sintaxe diferente para que o compilador entenda que n√£o queremos criar um vetor. No entanto, tamb√©m usamos 3 partes para declarar tal vari√°vel:

. `ClasseDeColecao` para indicar que queremos criar uma cole√ß√£o, utilizando alguma das classes do pacote `java.util`. A classe mais b√°sica para isso √© a `ArrayList`, que representa uma lista de objetos.
. `<ClasseDosItemsDaColecao>` para indicar qual a classe dos elementos que podem ser armazenados (perceba o uso de `<>` para isto, diferente dos `[]` usados para vetores).
. `nomeDaVariavel` o nome da vari√°vel que representar√° a cole√ß√£o. 

Um exemplo que cria uma cole√ß√£o de empresas pode ser `ArrayList<Empresa> empresas`. Neste caso estamos utilizando um tipo espec√≠fico de cole√ß√£o √© que uma lista (`List`), mais especificamente, um determinado tipo de lista que √© o `ArrayList`. Podemos ent√£o dizer que a vari√°vel `empresas` √© uma lista de empresas. 

Diversas linguagens de programa√ß√£o possuem esse conceito de cole√ß√µes. Apesar de cada linguagem implementar cole√ß√µes de uma forma diferente, podendo mudar termos e incluir outros, os fundamentos apresentados aqui tornar√£o mais f√°cil a utiliza√ß√£o de cole√ß√µes em outras linguagens. Parece ser muito complicado, mas logo voc√™ se acostuma, assim como vetores j√° √© um conceito familiar. 

Ent√£o finalmente, para declararmos nossa lista de empresas, vamos incluir o atributo `empresas` dentro da classe `Cidade`, como abaixo:

[source,java]
----
public class Cidade
{
    private String nome;
    private Estado estado;

    /**
     * Define o relacionamento Cidade -> Empresa como 1..n.
     */
    private ArrayList<Empresa> empresas;

    //Getters e setters omitidos por simplifica√ß√£o
}
----

Ao tentar compilar o c√≥digo da classe, ser√° gerado o erro _"cannot find symbol - class ArrayList"_, indicando que a classe `ArrayList` n√£o foi encontrada. Esta √© a primeira vez que vemos tal erro e ele ocorre pois a classe indicada est√° em um pacote espec√≠fico. Um diret√≥rio no disco √© uma forma de representa√ß√£o de pacotes em Java, contendo um conjunto de classes. `ArrayList` √© uma classe da linguagem, dispon√≠vel no pacote `java.util`. Desta forma, precisamos importar tal classe para podermos utiliz√°-la em nosso c√≥digo, incluindo um comando `import nome.do.pacote.NomeDaClassePraImportar;` na primeira linha do arquivo java onde a classe importada ser√° usada. Se voc√™ j√° programou em outras linguagens, este conceito de `import` √© o mesmo em linguagens como Python e vers√µes mais recentes do JavaScript. Em outras linguagens temos:

- `include` em C e PHP;
- `require` em PHP.

Desta forma, a linha `import java.util.ArrayList;` deve ser inclu√≠da como primeira linha do arquivo da classe `Cidade`.
Voc√™ pode estar se perguntando porque outras classes como `String` n√£o precisaram de um import. Isto se deve ao fato de que `String` √© uma classe do pacote chamado `java.lang` e o compilador Java importa automaticamente qualquer classe desse pacote, nos dispensando deste trabalho. Veremos mais sobre pacotes mais adiante. O c√≥digo da classe ent√£o fica como abaixo.

[source,java]
----
import java.util.ArrayList;

public class Cidade
{
    private String nome;
    private Estado estado;
    private ArrayList<Empresa> empresas;

    //Getters e setters omitidos por simplifica√ß√£o
}
----

Voltando ao nosso c√≥digo, vemos que `empresas` nada mais √© que um atributo da classe `Cidade`. Assim, o pr√≥ximo passo seria adicionar um _getter_ e um _setter_ para ele. No entanto, h√° um por√©m quando usamos uma cole√ß√£o. Se inclu√≠rmos um _setter_, ao chamar tal m√©todo, precisaremos informar uma lista completa de empresas situadas naquela cidade. Mas n√£o √© assim a forma tradicional de se preencher uma lista. Se resolvermos fazer uma lista de compras, vamos inclu√≠ndo os elementos em tal lista um a um. Assim tamb√©m √© a forma mais pr√°tica de ser feito em programa√ß√£o. No entanto, √© muito comum programadores iniciantes simplesmente criarem _getter_ e _setter_ para listas de forma autom√°tica, como fazem para qualquer atributo. O _getter_ ser√° √∫til para sabermos quais empresas h√° na cidade, mas o setter acabar√° n√£o sendo muito pr√°tico, pois como falado, a lista √© mais facilmente preenchida adicionando-se um elemento por vez.

Desta forma, criaremos o _getter_ e, no lugar do _setter_, vamos criar um m√©todo chamado `addEmpresa` que adicionar√° uma empresa √† lista de empresas da cidade. Assim, o c√≥digo da classe `Cidade` ficar√° como abaixo:

[source,java]
----
import java.util.ArrayList;

public class Cidade
{
    private String nome;
    private Estado estado;
    private ArrayList<Empresa> empresas;
    //Getters e setters para nome e estado omitidos por simplifica√ß√£o

    public ArrayList<Empresa> getEmpresas(){
        return empresas;
    }

    public void addEmpresa(Empresa empresa){
        empresas.add(empresa);
    }
}
----

O v√≠deo a seguir demonstra o processo de instancia√ß√£o de uma Empresa e uma Cidade. No entanto, como podem ver, ao tentar adicionar uma Empresa criada √† lista de empresas da Cidade, ocorre o erro NullPointerException.

video::jDlUtqXHAl4[youtube, 640, 480]

O erro ocorre pois estamos tentando utilizar a lista de empresas antes de termos instanciado a mesma.
Observe que em nenhum momento, dentro do c√≥digo da classe `Cidade`, utilizamos o operador `new` para criar uma 
lista vazia e assim podermos inserir empresas nela. Como √© √≥bvio, se vamos fazer uma lista de compras, primeiramente precisamos conseguir, por exemplo, uma folha de papel (preferencialmente em branco) para podermos come√ßar a adicionar os elementos na nossa lista. Este √© o passo que nos falta no c√≥digo acima. Como visto no link::chapter7.html[Cap√≠tulo 7], podemos utilizar um construtor para definir valores iniciais para atributos da nossa classe. Como `empresas` √© um atributo, podemos ent√£o instanci√°-lo em um construtor padr√£o na classe Cidade, e assim incluir nosso construtor depois do √∫ltimo atributo da classe (preferencialmente), como abaixo:

[source,java]
----
    public Cidade(){
        this.empresas = new ArrayList<Empresa>();        
    }
----

Se seguirmos os mesmos passos do v√≠deo acima, agora conseguiremos adicionar empresas √† lista de empresas da cidade, uma empresa por vez. Um detalhe que precisamos ter em mente √© a forma como uma `ArrayList` deve ser intanciada. Como j√° sabemos, a forma mais b√°sica de instanciar qualquer objeto √© `new NomeDaClasse()`. Apesar de a linha no construtor acima parece diferente, ela segue a mesma l√≥gica: utilizamos `new` seguido da classe do objeto que queremos instanciar. Neste caso, o tipo da vari√°vel `empresas` que armazenar√° uma refer√™ncia para tal objeto n√£o √© apenas `ArrayList`, mas sim `ArrayList<Empresa>`. O tipo de uma vari√°vel √© o que vem imediatamente antes dela. 

Se olharmos a declara√ß√£o de `empresas` no c√≥digo anterior ao mostrado acima, veremos que o que vem antes do nome do atributo √© `ArrayList<Empresa>`. Observe que n√£o h√° espa√ßo entre `ArrayList` e `<Empresa>` (apesar de ser perfeitamente v√°lido incluir espa√ßo), indicando que eles s√£o uma coisa s√≥, representando um √∫nico tipo: uma lista de empresas.

Assim, para instanciar tal lista, precisamos usar `new ArrayList<Empresa>();` e n√£o `new ArrayList();`.
Esta √∫ltima forma mostrada funciona, mas n√£o √© a maneira correta de instanciar objetos como cole√ß√µes desde o Java 5, que foi lan√ßado em 2004. Se voc√™ usar esta segunda forma, √© como se tivesse parado no tempo h√° mais de uma d√©cada, o que seria uma vergonha üòí. 

Avan√ßando alguns anos para o Java 7 de 2011, deixamos de precisar indicar o tipo de elementos da cole√ß√£o no momento de instanci√°-la. S√≥ precisamos fazer isso ao declarar as vari√°veis. Assim, podemos apenas deixar o `<>` vazio dentro do construto. Se utilizarmos da forma acima, ferramentas de desenvolvimento v√£o sugerir que aquela n√£o √© a forma mais adequada e atual. Nosso classe ent√£o fica como abaixo:

----
import java.util.ArrayList;

public class Cidade
{
    private String nome;
    private Estado estado;
    private ArrayList<Empresa> empresas;
    //Getters e setters para nome e estado omitidos por simplifica√ß√£o

    public Cidade(){
        //Observe que removemos o tipo dos elementos da lista de dentro do <>.
        //Isto s√≥ pode ser feito no momento de instanciar a lista.
        this.empresas = new ArrayList<>();        
    }

    public ArrayList<Empresa> getEmpresas(){
        return empresas;
    }

    public void addEmpresa(Empresa empresa){
        empresas.add(empresa);
    }
}
----

=== Re-analisando a implementa√ß√£o de um relacionamento 1..n

O processo de cria√ß√£o de relacionamentos 1..n √© obviamente mais complicado que os 1..1. Para isto tivemos que:

. declarar um atributo `empresas` dentro da classe `Cidade`, sendo este um `ArrayList` de objetos `Empresa`; 
. criar uma lista vazia no construtor da classe, instanciando um `ArrayList` de objetos `Empresa`;
. incluir um _getter_ para podermos saber quais s√£o as empresas da cidade;
. incluir o m√©todo `addEmpresa` no lugar do _setter_, que torna mais simples o preenchimento da lista de cidades (adicionando uma cidade por vez). 

Apesar de o c√≥digo apresentado funcionar perfeitamente, e este √© o tipo de c√≥digo que encontrar√£o muito por a√≠, aquela n√£o √© a forma mais adequada de de usarmos cole√ß√µes como o `ArrayList`. Vamos discutir os detalhes logo para que voc√™ se habitue a forma mais adequada e evite v√≠cios que muitos programadores t√™m.

Como discutido anteriormente, a Java Collections Framework (JCF) possui uma s√©rie de diferentes classes para representar cole√ß√µes. Temos classes que representam, por exemplo:

- listas (`List`), permitindo armazenar elementos repetidos;
- conjuntos (`Set`), n√£o permitindo armazenar elementos repetidos.

Para cada tipo de cole√ß√£o temos classes adicionais que fornecem implementa√ß√µes espec√≠ficas, como:

- `ArrayList` e `LinkedList` para listas;
- `HashSet` e `TreeSet` para conjuntos.

NOTE: `List` e `Set` n√£o s√£o de fato classes, mas n√£o vamos nos ater a isso por enquanto.

Todas as classes que representam listas possuem os mesmos m√©todos. Assim, a forma de utilizar uma `ArrayList` √© a mesma de uma `LinkedList`. O mesmo vale para tipos outros tipos como `Set`. Cada classe fornece uma implementa√ß√£o diferente da outra. Por exemplo, uma `ArrayList` utiliza um vetor internamente para armazenar os dados. Voc√™ lembra que falamos que vetores tem tamanho limitado. Mostramos que, depois de criado, a √∫nica forma de aumentar o total de elementos em um vetor √© criar um novo vetor maior e copiar os dados do antigo para este novo. Ao utilizar uma `ArrayList`, todo esse processo j√° est√° implementando internamente. N√£o precisamos nos preocupar com nada. Apenas adicionamos elementos √† lista. Se o vetor interno encher, a classe se encarrega de executar o processo descrito acima para criar um vetor maior. 

O v√≠deo abaixo demonstra este processo. Iniciamos criando uma cidade. Ao verificar a `ArrayList` `empresas`, observamos que o tamanho (_size_) da lista √© 0. Ao adicionar a primeira empresa e voltar a visualizar o atributo `empresas` na cidade criada, o tamanho agora √© 1. Podemos ver que as empresas s√£o armazenadas dentro da `ArrayList` em um vetor chamado `elementData`. Ao clicar duas vezes nele, descobrimos que o vetor tem capacidade (_length_) para 10 elementos, mas apenas o elemento 0 possui uma Empresa. Ao clicar duas vezes em tal elemento, conseguimos ver qual √© a empresa de fato. 

Em seguida criamos mais 9 empresas, totalizando 10, e adicionamos √† cidade, o que far√° com que o vetor fique cheio. Ao criarmos e adicionarmos a 11¬™ empresa, veremos que s√£o criadas mais 5 posi√ß√µes para armazenar novos elementos. Isso ocorrer√° cada vez que o vetor encher e tentarmos adicionar um novo elemento. Toda essa m√°gica acontece internamente na classe, criando um vetor maior e copiando os dados do antigo, sem que ao menos percebamos que um novo vetor foi criado (aparentemente a classe apenas aumentou o vetor existente).

video::DDNVXq3JIiQ[youtube, 640, 480]

A quest√£o √© que, se temos diferentes tipos de `List` e `Set`, podemos uma hora querer trocar de um tipo para outro, pois avaliamos que o tipo anteriormente escolhido n√£o est√° sendo adequado ou eficiente para as atuais necessidades do nosso sistema. No mundo real por exemplo, podemos utilizar diferentes meios para criar uma lista de compras, como uma folha de papel ou um aplicativo no celular. Dependendo do tipo de lista que usarmos, teremos vantagens e desvantagens. Uma lista de papel pode ser utilizada por qualquer pessoa, mas pode encher e n√£o termos mais espa√ßo para incluir novos itens e altera√ß√£o ou remo√ß√£o de itens requer resurar o papel. 

J√° um app no celular tem in√∫meras vantagens, como permitir: incluir quantos itens desejarmos; facilmente alterar ou remover itens; mudar a ordem para facilitar a coleta dos produtos no supermercado (por exemplo, colocando as frutas e verduras todas em sequ√™ncia na lista). Por outro lado, nem todas as pessoas conseguem utilizar tais apps ou a bateria do celular pode esgotar e ficarmos sem lista.

Cada tipo de lista tem suas vantagens e desvantagens, mas a forma de utilizar listas de papel √© muito diferente de utilizar um app no celular. Se voc√™ tentar fazer seus av√≥s criarem e usarem um app de celular para isto, eles podem simplesmente odiar e terem dificuldade para se adaptar. N√£o seria √≥timo se pud√©ssemos trocar o tipo de lista sem que precis√°ssemos reaprender algo?
√â exatamente esta a quest√£o de re-avaliarmos o c√≥digo usado anteriormente para criar a lista de empresas.

Como usamos um `ArrayList`, declaramos o atributo com este tipo e inclu√≠mos um _getter_ que explicitamente indica que o tipo de lista √© `ArrayList`. Se descobrirmos que `ArrayList` n√£o √© o tipo mais adequado para nosso problema, teremos que alterar isto na declara√ß√£o do atributo, no construtor da classe onde a lista est√° sendo instanciada e no _getter_. 

Adicionalmente, como o _getter_ √© p√∫blico, tal m√©todo pode estar sendo utilizado em qualquer parte do nosso c√≥digo. Se este √© um projeto que disponibilizamos como c√≥digo aberto na Internet, possivelmente outras pessoas estar√£o declarando vari√°veis do tipo `ArrayList` para poder armazenar o resultado do m√©todo `getEmpresas()` e fazer opera√ß√µes sobre tal lista (como exibir as empresas nela). Se resolvermos utilizar um outro tipo de lista como `LinkedList`, teremos que alterar todos os locais citados no nosso c√≥digo e ainda feremos com que qualquer desenvolvedor que esteja utilizando o `getEmpresas()` tenha que atualizar seu c√≥digo se for compilar utilizando a vers√£o modificada da nossa classe `Cidade`.

Para evitar este problema, uma vez que qualquer lista possui os mesmos m√©todos p√∫blicos, n√£o devemos declarar o atributo utilizando um tipo espec√≠fico como `ArrayList`, mas sim um tipo mais gen√©rico, neste caso o `List`. Neste caso, teremos que alterar todos os locais na classe onde h√° `ArrayList` para `List`, como mostrado abaixo:

[source,java]
----
import java.util.List;

public class Cidade
{
    private String nome;
    private Estado estado;
    private List<Empresa> empresas;
    //Getters e setters para nome e estado omitidos por simplifica√ß√£o

    public Cidade(){
        this.empresas = new List<>();        
    }

    public List<Empresa> getEmpresas(){
        return empresas;
    }

    public void addEmpresa(Empresa empresa){
        empresas.add(empresa);
    }
}
----

Observe que alteramos o `import`, a declara√ß√£o do atributo, a instancia√ß√£o dentro do construtor e por fim o _getter_. Por√©m, ao tentar compilar ser√° exibido o erro _"java.util.List is abstract; cannot be instantiated"_, indicando que `List` √© um tipo abstrato e n√£o pode ser instanciado. Vamos falar sobre abstra√ß√£o e tipos abstratos mais adiante. Por enquanto, o que precisa saber √© que `List` (assim como `Set`) define apenas quais m√©todos p√∫blicos os diferentes tipos de lista como `ArrayList` e `LinkedList` obrigatoriamente ter√£o. O tipo `List` de fato n√£o implementa a grande maioria desses m√©todos. Assim, `List` serve apenas como um modelo, um prot√≥tipo que n√£o √© funcional. `ArrayList` e `LinkedList` s√£o classes totalmente funcionais, criadas a partir do modelo fornecido pela `List`. A `List` seria como um projeto inacabado de uma algo, enquanto `ArrayList` seria o projeto final. 

Por exemplo, o projeto de uma casa pode iniciar apenas com a parte estrutural, que inclui o alicerce e estruturas de sustenta√ß√£o das paredes e teto. Somente isto torna o projeto incompleto. Em fases seguintes √© preciso incluir outros projetos como o el√©trico. Assim, a `List` seria um projeto estrutural, enquanto `ArrayList` e `LinkedList` complementariam tal projeto, formando um projeto completo e funcional. Assim, o c√≥digo completo e final da classe `Cidade` √© como mostrado abaixo. Observe que tivemos que importar tanto `List` quando `ArrayList` pois estamos utilizando os dois tipos.


[source,java]
----
import java.util.List;
import java.util.ArrayList;

public class Cidade
{
    private String nome;
    private Estado estado;    
    private List<Empresa> empresas;
    
    public Cidade(){ 
        this.empresas = new ArrayList<>(); 
    }
    
    public String getNome(){ 
        return nome; 
    }
    
    public void setNome(String nome){ 
        this.nome = nome; 
    }
    
    public Estado getEstado(){ 
        return estado; 
    }
    
    public void setEstado(Estado estado){ 
        this.estado = estado; 
    }
    
    public List<Empresa> getEmpresas(){ 
        return empresas; 
    }

    public void addEmpresa(Empresa empresa){
        empresas.add(empresa);
    }
}
----


== Repensando a cardinalidade

Apesar de ser natural pensarmos na cardinalidade de `Empresa` -> `Cidade` como 1..1, na verdade tal cardinalidade √© n..1, ou seja, v√°rios objetos `Empresa` podem estar relacionados √† mesma cidade. Logo, podemos ter v√°rias empresas na mesma cidade. Voc√™ pode pensar que seria o mesmo que dizer que 1 `Empresa` est√° relacionada a 1 `Cidade`. Se pensarmos assim, podemos representar a cardinalidade e dire√ß√£o da associa√ß√£o entre essas duas classes como 1 -> 1. No entanto, se apenas invertermos a seta para avaliarmos o relacionamento no sentido contr√°rio (`Empresa` <- `Cidade`), teremos 1 <- 1. Lendo na dire√ß√£o da seta indica que 1 `Cidade` possui no m√°ximo 1 `Empresa`.

Sabemos que isto n√£o √© verdade, uma cidade pode ter v√°rias (n) empresas. Por esse motivo, no lugar de interpretarmos relacionamentos semelhantes √† `Empresa` -> `Cidade` como 1 -> 1, √© mais simples interpretarmos como n -> 1. Assim, se criarmos o relacionamento no sentido contr√°rio, s√≥ precisamos inverter a seta e teremos n <- 1, indicando que 1 cidade pode ter v√°rias empresas.

// Estritamente falando, relacionamentos 1..1 tem um significado diferente daquele que √© obvio. Eles indicam que um objeto da classe de origem se relaciona com no m√°ximo 1 objeto da classe de destino e que o objeto da classe de destino se relaciona apenas com aquele objeto da classe de origem, n√£o podendo se relacionar com nenhum outro objeto daquela classe. 


== Leituras Recomendadas

- https://www.caelum.com.br/apostila-java-orientacao-objetos/um-pouco-de-arrays/[Curso Java e Orienta√ß√£o a Objetos: Um pouco de arrays. Caelum.]
- https://www.caelum.com.br/apostila-java-orientacao-objetos/collections-framework/#arrays-so-trabalhosos-utilizar-estrutura-de-dados[Curso Java e Orienta√ß√£o a Objetos: Collections framework. Caelum.]